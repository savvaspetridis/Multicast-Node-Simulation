<!--

index.html for Multicast Simulator app:

by: Raphael Norwitz and Savvas Petridis

Note: This page is a template using both AngularJS and Django syntax, which sometimes cause syntax collisions. 
The solution to htis is to use verbatim tags, which are all in comments. Thus do not alter any comments in this template as 
they will affect how django parses the code.

-->


<!doctype html>
<html lang="en" ng-app="app">


<!--{% verbatim %}-->


<head>
	<meta charset="UTF-8">
	<title> Multicast Simulator </title>

	<!--

	This style tag contains all the styles currently used in this page. 
	The 'fixed' tag fixes the table cell size.
	The generic table tag ensures that the table has borders
	the .something tags are all used to color the cells. 
	To add another color to the simulator, add a .someColor tag where someColor is the color you
	want to add, and just set the background-color attribute equal to the color you want. 
	See comments on the <td> tag for next instruction on adding colors


	-->
	<style type="text/css">

	table.fixed { table-layout:fixed; }
	table.fixed td { overflow: hidden; }

	table, th, td {
		border: 1px solid black;

	}
	.feedback{
		outline: red dotted thick;
	}
	.green {
		background-color: LightGreen;	 
	}
	.yellow
	{
		background-color: yellow;
	}
	.blue
	{
		background-color: LightBlue;
	}
	.red
	{
		background-color: FireBrick;
	}
	.grey
	{
		background-color: LightGrey;
	}
	.black
	{
		background-color: black;
	}

	</style>
	<style src="https://rawgit.com/jtblin/angular-chart.js/master/dist/angular-chart.css"> </style>

	<!--these scripts import angular and raphael js-->
	<script src="http://code.angularjs.org/1.2.2/angular.min.js"> </script>
	<script src="https://rawgit.com/nnnick/Chart.js/master/Chart.min.js"></script>
	<script src="https://rawgit.com/jtblin/angular-chart.js/master/dist/angular-chart.js"></script>
	
	<!--<script src="https://code.angularjs.org/X.Y.Z/angular-route.js"> </script>-->




</head>


<body >
	<h1 align = "center"><b>Multicast Simulator</b></h1>


<!--this whole div creates the table-->
<div ng-controller= "theController" align = "center">
	<div>

	<!--{% endverbatim %} -->

	<form action="." method="post"> {% csrf_token %}
		<div class="fieldWrapper">
			<label for="{{ form.bitRate.id_for_label }}" >Bit Rate:</label>
			{{ form.bitRate }}
		</div>
		<div class="fieldWrapper" ng-show="showUpdate">
			<label for="{{ form.updateInterval.id_for_label }}">Update Interval:</label>
			{{ form.updateInterval }}
		</div>
		<div class="fieldWrapper">
			<label for="{{ form.fbNodeAlg.id_for_label }}">F.B.N. Algorithm:</label>
			{{ form.fbNodeAlg }}
			<label for="{{ form.fbNodeAlg.id_for_label }}" ng-show="showK">k:</label>
			{{ form.k }}
			<label for="{{ form.fbNodeAlg.id_for_label }}" ng-show="showDistance">Distance (Amuse):</label>
			{{ form.d }}
		</div>
		<div class="fieldWrapper" ng-hide="showBitRate">
			<label for="{{ form.fbNodeAlg.id_for_label }}">H-low Threshold</label>
			{{ form.H}}
			<label for="{{ form.fbNodeAlg.id_for_label }}">Variability of PDR allowed</label>
			{{ form.Delta}}
			<label for="{{ form.fbNodeAlg.id_for_label }}">Window minimum</label>
			{{ form.W_min}}
			<label for="{{ form.fbNodeAlg.id_for_label }}">Window maximum</label>
			{{ form.W_max}}
			<label for="{{ form.fbNodeAlg.id_for_label }}">Time</label>
			{{ form.time}}
			<label for="{{ form.fbNodeAlg.id_for_label }}">Maximum abnormal nodes</label>
			{{ form.A_max}}
		</div>
		<input type="submit" value="Resubmit"  />
	</form>

	<!-- {% verbatim %} -->
	
	<br />
	
	<b>

		<h2>{{(COUNTER * intervalCount)}} seconds</h2>

		<table ng-show="showGraphs">
			<tr>
				<td>
					Maximum Node: {{maxNode}}
				</td>
				<td>
					Minimum Node: {{minNode}}
				</td>
				<td>
					Average Node: {{avgNode}}
				</td>
			</tr>
		</table>
		

		
		<table class="fixed" width = "75%" >
			

			<th>
				<!--

				this ng-repeat iterates through the array of areas returned by django (lists of pdr values for each area)
				to find the area indexes (eg. 1-'', 2-'', 3-''...20-'') 				
				-->
				<td ng-repeat="area in Interval" width="4.85%">{{$index+1}}</td>

			</th>

			
			<!--
				
				This ng-repeat similarly loops through all the areas in the interval

			-->
			<tbody ng-repeat="area in Interval">
				<tr class="nodeRow">
					<!--gets the individual node numbers within the interval (the horizontal header on the table)-->
					<td>
						{{$index+1}}
					</td>
					<!--

						this tag both prints the node value in the box and determines the boxes color

						to add another color to the interval,  append the current string inside the {} in ng-class tag by:
						
						", 'x' : classSelectors[$parent.$index][$index][y]"

						where x is the color you want to add and y is the highest 'y' value in the expression thus far incremented by 1

						to finish adding a color see the comments inside the angular controller

					-->
					<td ng-repeat= "node in area track by $index" ng-class = "{'feedback' : classSelectors[$parent.$index][$index][0], 'grey' : classSelectors[$parent.$index][$index][1], 'blue' : classSelectors[$parent.$index][$index][2], 'yellow' : classSelectors[$parent.$index][$index][3], 'green' : classSelectors[$parent.$index][$index][4], 'black' : classSelectors[$parent.$index][$index][5], 'red' : classSelectors[$parent.$index][$index][6] }">
						{{node}}
						<!-- {% endverbatim %}-->
					</td>

				</tr> 
			</tbody>
			
		
		</table>

		<div ng-show="showGraphs">
		
			<canvas id="line" width='2400' height='400' class="chart chart-line ng-scope" data="bit_rates_wrapper" labels="times_graph" legend="true" series="series_bit_rate">
			</canvas>

			
			

		</div>

		<div ng-show="showGraphs">
		
			<canvas id="line" width='2400' height='400' class="chart chart-line ng-scope" data="throughput_wrapper" labels="times_graph" legend="true" series="series_throughput">
			</canvas>

			
			

		</div>




		<div>
			
			
	</b>
	<hr />
	<div>
		<button type="button" data-ng-click="play()">Play</button>
		<button type="button" data-ng-click="stop()">Pause</button>
	</div>
</div>
	

	
</div>


<!--{% load staticfiles %}-->

<!--<script src="{% static "tableController.js" %}"></script>-->
<!--

	to bypass Django statics, uncomment this script tag and comment out the one above-->

	<!--<script src="https://rawgit.com/savvaspetridis/Multicast-Node-Simulation/master/amuse_project/multicast_simulator/templates/multicast_simulator/tableController.js"> </script>-->


<!--<script>
var app = angular.module('app', ['chart.js'] ).config(function($httpProvider) {
$httpProvider.defaults.xsrfCookieName = 'csrftoken';
$httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';
});
app.controller('theController', ['$scope', '$interval', '$http', '$templateCache', function($scope, $interval, $http, $templateCache)
{

	

	// get double array of node objects returned by django

	//won't keep this

	//var dataDump = {{intervalList}};
	
	//this serves as the counter for the controller and it is updated every interval
	$scope.i = 1;
	$scope.totalTime = 0;

	// for bit rates graph
	$scope.bit_rates_wrapper = []; 
	$scope.bit_rates_graph = [];		
	$scope.bit_rates_wrapper.push($scope.bit_rates_graph);
	$scope.times_graph =[];
	$scope.series_bit_rate = ['bit-rate vs. time (seconds)',];

	// for throughput graph		
	$scope.throughput_wrapper = [];
	$scope.throughput_graph = [];
	$scope.throughput_wrapper.push($scope.throughput_graph);
	$scope.series_throughput = ['throughput (megabits) vs. time (seconds)',];

	$scope.showGraphs = false;


	// for min max avg node statistics
	$scope.minNode;
	$scope.maxNode;
	$scope.avgNode;

	// for other user input
	$scope.H = 88;
	$scope.Delta = 3;
	$scope.W_min = 4;
	$scope.W_max = 16;
	$scope.windowTime = 20;
	$scope.A_max = 10;




	// will be calculaed by django 
	$scope.Interval;
	$scope.intervalBuffer = [];
	$scope.COUNTER = $scope.totalTime;
	$scope.classSelectors;
	$scope.intervalCount = 0.5;
	$scope.bit_rate = 6;
	$scope.bit_rate_update = $scope.bit_rate;
	$scope.numSlides = (8.0 / $scope.intervalCount);


	// will be calculated at each interval by django
	$scope.feedbackNodes = [];
	$scope.showUpdate = true;
	$scope.showBitRate = true;
	$scope.showK = false;
	$scope.showDistance = false;
	$scope.algorithms = ['NONE', 'WORST', 'RAND', 'AMUSE'];
	$scope.k_nodes = 6;
	$scope.distance = 1;



	// django puts this here
	$scope.my ={option : 'NONE'};
	//$scope.method = 'JSONP';
	$scope.url = '/update';


	var promise;


	$scope.play = function()
	{
		if( angular.isDefined(promise))
			return;
		$scope.showUpdate = false;

		$scope.run_calculations();

		promise = $interval($scope.run_calculations, $scope.intervalCount * 1000);
	};

	$scope.run_calculations = function()
	{
		$scope.fetch();

		$scope.numSlides = (8.0 / $scope.intervalCount);
		


		// for min max avg node statistics
		$scope.minNode = 100.0;
		$scope.maxNode = 0.0;
		$scope.avgNode = 0.0;


		//$scope.Interval; // set the interval equal to the ith index in the dataDump variable

		
		var currVals = $scope.intervalBuffer;
		if(currVals == null)
		{
			console.log("hello");
		}
		var intervalColors = [];
		//var currFeed = $scope.feedbackNodes;
		$scope.check();
		$scope.COUNTER = $scope.totalTime;

		/*
			
			The last thing you need to do to add a color is to add an if-else
			condition at the bottom of the nested foroop (see location of comment in code) in this format:

				if(currVals[j][l] <= someValue && currVals[j][l] > anotherValue) // or if(currVals[j][l] == someValue)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}

			If you want to change the ranges just update the values


		*/

		$scope.avgCheck = 0;
		




		for(var j = 0; j < $scope.intervalBuffer.length; j++)
		{
			var areaColors = [];
			var checkArray = $scope.intervalBuffer[j];
			for(var l = 0; l < checkArray.length; l++)
			{
				var nodeColorBooleans = [];

				if($scope.feedbackNodes[j][l] == 1)
				{
					nodeColorBooleans.push(true);

				}
				else
				{
					nodeColorBooleans.push(false);
				}

				
				if (currVals[j][l] == 0.0)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}

				if (currVals[j][l] <= 50.0 && currVals[j][l] > 25.0)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}

				if (currVals[j][l] <= 75.0 && currVals[j][l] > 50.0)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}

				if (currVals[j][l] > 75.0)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}
				if (currVals[j][l] < 0)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}
				if(currVals[j][l] == -100.0) // or if(currVals[j][l] == someValue)
				{
					nodeColorBooleans.push(true);
					$scope.avgCheck = $scope.avgCheck + 1;
				}
				else
				{
					nodeColorBooleans.push(false);
				}
				if(currVals[j][l] <= 25.0 && currVals[j][l] > 0.0) // or if(currVals[j][l] == someValue)
				{
					nodeColorBooleans.push(true);
				}
				else
				{
					nodeColorBooleans.push(false);
				}


				// add any new if-else conditionals (as described above) here

				areaColors.push(nodeColorBooleans);

				if(currVals[j][l] > $scope.maxNode)
				{
					$scope.maxNode = currVals[j][l];

				}
				if(currVals[j][l] < $scope.minNode && currVals[j][l] > 0.0)
				{
					$scope.minNode = currVals[j][l];
				}
				if(currVals[j][l] > 0.0)
				{
					$scope.avgCheck = $scope.avgCheck + 1;
					$scope.avgNode = $scope.avgNode + currVals[j][l];
				}
				
			}
			intervalColors.push(areaColors);
		}
		$scope.classSelectors = intervalColors;	
		
		$scope.i = $scope.i+ 1;
		$scope.totalTime = $scope.totalTime + 1;

		
		if($scope.i == $scope.numSlides +1 || $scope.bit_rate != $scope.bit_rate_update)
		{
			$scope.i = 1;
		}


		// add bit rate info to graph
		$scope.times_graph.push($scope.COUNTER * $scope.intervalCount);
		if($scope.times_graph.length > 10)
		{
			$scope.times_graph.shift();
		}
		$scope.bit_rates_wrapper[0].push($scope.bit_rate_update);

		if($scope.bit_rates_wrapper[0].length > 10)
		{
			$scope.bit_rates_wrapper[0].shift();
		}

		$scope.throughput_wrapper[0].push($scope.bit_rate_update * $scope.COUNTER * $scope.intervalCount);

		if($scope.throughput_wrapper[0].length >10)
		{
			$scope.throughput_wrapper[0].shift();
		}

		$scope.bit_rate = $scope.bit_rate_update;

		$scope.avgNode = $scope.avgNode / $scope.avgCheck;

		$scope.Interval = $scope.intervalBuffer;
		$scope.showGraphs = true;
	}
			
	$scope.stop = function(){
		$interval.cancel(promise);
		promise = undefined;
	};

	$scope.check = function()
	{
		if($scope.my.option == 'NONE')
			{
				$scope.showBitRate = true;
				//$scope.showK = false;
				//$scope.showDistance = false

			}
			else
			{
				$scope.showBitRate = false;
			}

			if($scope.my.option == 'RAND' || $scope.my.option == 'WORST')
			{
				$scope.showK = true;
				$scope.showDistance = false;
			}
			else
			{
				$scope.showK = false;
			}

			if($scope.my.option == 'AMUSE')
			{
				$scope.showDistance = true;
				//$scope.showK = false;
			}
			else
			{
				$scope.showDistance = false;
			}
	};

	$scope.fetch = function(){

		$http.post($scope.url, {
			updateInterval: $scope.intervalCount,
			Algorithm: $scope.my.option,
			count: $scope.i,
			b_rate: $scope.bit_rate_update,
			k: $scope.k_nodes,
			dist: $scope.distance,
			H_low: $scope.H,
			Delta: $scope.Delta,
			W_min: $scope.W_min,
			W_max: $scope.W_max,
			time: $scope.windowTime,
			A_max: $scope.A_max
		}).
		success(function(data, status, headers, config){
			$scope.intervalBuffer = data.pdr_set;
			//test this after you know interval works
			$scope.feedbackNodes = data.feedback_set;
			$scope.bit_rate_update = data.bit_rate;
		}).
		error(function(data, status)
		{
			$scope.Interval = [0,0, 0];
			$scope.feedbackNode = [];
			console.log("here");


		});
		
	};


	//$scope.play();
}]);


</script>-->
	
</body>
</html>