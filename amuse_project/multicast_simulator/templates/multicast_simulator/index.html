<!--

index.html for Multicast Simulator app:

by: Raphael Norwitz and Savvas Petridis

Note: This page is a template using both AngularJS and Django syntax, which sometimes cause syntax collisions. 
The solution to htis is to use verbatim tags, which are all in comments. Thus do not alter any comments in this template as 
they will affect how django parses the code.

-->


<!doctype html>
<html lang="en" ng-app="app">


<!--{% verbatim %}-->


<head>
	<meta charset="UTF-8">
	<title> multicast simulator </title>

	<!--

	This style tag contains all the styles currently used in this page. 
	The 'fixed' tag fixes the table cell size.
	The generic table tag ensures that the table has borders
	the .something tags are all used to color the cells. 
	To add another color to the simulator, add a .someColor tag where someColor is the color you
	want to add, and just set the background-color attribute equal to the color you want. 
	See comments on the <td> tag for next instruction on adding colors


	-->
	<style type="text/css">

	table.fixed { table-layout:fixed; }
	table.fixed td { overflow: hidden; }

	table, th, td {
		border: 1px solid black;

	}
	.feedback{
		outline: green dotted thick;
	}
	.green {
		background-color: LightGreen;	 
	}
	.yellow
	{
		background-color: yellow;
	}
	.blue
	{
		background-color: LightBlue;
	}
	.red
	{
		background-color: red;
	}
	.grey
	{
		background-color: LightGrey;
	}
	.black
	{
		background-color: black;
	}

	</style>

	<!--these scripts import angular and raphael js-->
	<script src="http://code.angularjs.org/1.2.2/angular.min.js"> </script>
	<script type="text/javascript" src="http://github.com/DmitryBaranovskiy/raphael/raw/master/raphael-min.js"></script>
	<script type="text/javascript" src="tableController.js"></script>


</head>


<body >
	<h1 align = "center"><b>Multicast Simulator</b></h1>


<!--this whole div creates the table-->
<div ng-controller= "theController" align = "center">

	<!--{% endverbatim %} -->

	<form action="." method="post"> {% csrf_token %}
		<div class="fieldWrapper" ng-show="showBitRate">
			<label for="{{ form.bitRate.id_for_label }}" >Bit Rate:</label>
			{{ form.bitRate }}
		</div>
		<div class="fieldWrapper">
			<label for="{{ form.updateInterval.id_for_label }}">Update Interval:</label>
			{{ form.updateInterval }}
		</div>
		<div class="fieldWrapper">
			<label for="{{ form.fbNodeAlg.id_for_label }}">F.B.N. Algorithm:</label>
			{{ form.fbNodeAlg }}
			<label for="{{ form.fbNodeAlg.id_for_label }}" ng-show="showK">k:</label>
			{{ form.k }}
			<label for="{{ form.fbNodeAlg.id_for_label }}" ng-show="showDistance">Distance (Amuse):</label>
			{{ form.d }}
		</div>
		<input type="submit" value="Submit"  />
	</form>

	<!-- {% verbatim %} -->
	
	<br />
	
	<b>

		<h2>{{(COUNTER * intervalCount)}} seconds</h2>
		

		
		<table class="fixed" width = "75%" >
			

			<th>
				<!--

				this ng-repeat iterates through the array of areas returned by django (lists of pdr values for each area)
				to find the area indexes (eg. 1-'', 2-'', 3-''...20-'') 				
				-->
				<td ng-repeat="area in Interval" width="5%">{{$index+1}}</td>
			</th>

			
			<!--
				
				This ng-repeat similarly loops through all the areas in the interval

			-->
			<tbody ng-repeat="area in Interval">
				<tr class="nodeRow">
					<!--gets the individual node numbers within the interval (the horizontal header on the table)-->
					<td>
						{{$index+1}}
					</td>
					<!--

						this tag both prints the node value in the box and determines the boxes color

						to add another color to the interval,  append the current string inside the {} in ng-class tag by:
						
						", 'x' : classSelectors[$parent.$index][$index][y]"

						where x is the color you want to add and y is the highest 'y' value in the expression thus far incremented by 1

						to finish adding a color see the comments inside the angular controller

					-->
					<td ng-repeat= "node in area track by $index" ng-class = "{'feedback' : classSelectors[$parent.$index][$index][0], 'grey' : classSelectors[$parent.$index][$index][1], 'blue' : classSelectors[$parent.$index][$index][2], 'yellow' : classSelectors[$parent.$index][$index][3], 'green' : classSelectors[$parent.$index][$index][4] }">
						{{node}}
					</td>

				</tr> 
			</tbody>
			
		
		</table>
		<div>
			{{k_nodes}}
			{{intervalCount}}
			{{bit_rate}}
			{{k}}
			{{dist}}


		


	</b>
	<hr />
	<div>
		<button type="button" data-ng-click="play()">Play</button>
		<button type="button" data-ng-click="stop()">Pause</button>
	</div>
	

	
</div>



	<script>
	var app = angular.module('app', []).config(function($httpProvider) {
    $httpProvider.defaults.xsrfCookieName = 'csrftoken';
    $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';
	});
	app.controller('theController', ['$scope', '$interval', '$http', '$templateCache', 
		function($scope, $interval, $http, $templateCache){

			
			//{% endverbatim %}

			// get double array of node objects returned by django

			//won't keep this

			//var dataDump = {{intervalList}};
			
			//this serves as the counter for the controller and it is updated every interval
			$scope.i = 0;
			var totalTime = 0;


			// will be calculaed by django 
			$scope.Interval;
			$scope.COUNTER = totalTime;
			$scope.classSelectors;
			$scope.intervalCount = {{interval}};
			$scope.bit_rate = {{bit_rate}};
			$scope.bit_rate_update = $scope.bit_rate;
			$scope.numSlides = (8.0 / $scope.intervalCount);


			// will be calculated at each interval by django
			$scope.feedbackNodes;
			$scope.showBitRate = true;
			$scope.showK = true;
			$scope.showDistance = false;
			$scope.algorithms = ['NONE', 'WORST', 'RAND', 'AMUSE'];
			$scope.k_nodes = {{k}};
			$scope.distance = {{dist}};



			// django puts this here
			$scope.my ={option : '{{alg}}'};
			//$scope.method = 'JSONP';
			$scope.url = '/update';


			var promise;


			$scope.play = function()
			{
				if( angular.isDefined(promise))
					return;

				promise = $interval(function(){
					$scope.fetch();


					//$scope.Interval; // set the interval equal to the ith index in the dataDump variable

					$scope.COUNTER = totalTime;
					var currVals = $scope.Interval;
					var intervalColors = [];
					var currFeed = $scope.feedbackNodes;
					$scope.check();

					/*
						
						The last thing you need to do to add a color is to add an if-else
						condition at the bottom of the nested for-loop (see location of comment in code) in this format:

							if(currVals[j][l] <= someValue && currVals[j][l] > anotherValue) // or if(currVals[j][l] == someValue)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}

						If you want to change the ranges just update the values


					*/

					for(var j = 0; j < currVals.length; j++)
					{
						var areaColors = [];
						var checkArray = currVals[j];
						for(var l = 0; l < checkArray.length; l++)
						{
							var nodeColorBooleans = [];

							if(currFeed[j][l] == 1)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}

							
							if (currVals[j][l] <= 25.0)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}

							if (currVals[j][l] <= 50.0 && currVals[j][l] > 25.0)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}

							if (currVals[j][l] <= 75.0 && currVals[j][l] > 50.0)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}

							if (currVals[j][l] > 75.0)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}
							if (currVals[j][l] < 0)
							{
								nodeColorBooleans.push(true);
							}
							else
							{
								nodeColorBooleans.push(false);
							}

							// add any new if-else conditionals (as described above) here

							areaColors.push(nodeColorBooleans);
							
						}
						intervalColors.push(areaColors);
					}
					$scope.classSelectors=intervalColors;	
					
					$scope.i = $scope.i+ 1;
					totalTime = totalTime + 1;
 
					
					if($scope.i == $scope.numSlides || $scope.bit_rate != $scope.bit_rate_update)
					{
						$scope.i = 0;
					}

					$scope.bit_rate = $scope.bit_rate_update;

						
				}, {{interval}} * 1000);
		};
				
		$scope.stop = function(){
			$interval.cancel(promise);
			promise = undefined;
		};

		$scope.check = function()
		{
			if($scope.my.option == 'NONE')
				{
					$scope.showBitRate = true;
					//$scope.showK = false;
					//$scope.showDistance = false

				}
				else
				{
					$scope.showBitRate = false;
				}

				if($scope.my.option == 'RAND' || $scope.my.option == 'WORST')
				{
					$scope.showK = true;
					$scope.showDistance = false;
				}
				else
				{
					$scope.showK = false;
				}

				if($scope.my.option == 'AMUSE')
				{
					$scope.showDistance = true;
					//$scope.showK = false;
				}
				else
				{
					$scope.showDistance = false;
				}
		};

		$scope.fetch = function(){

			$http.post($scope.url, {
				updateInterval: $scope.intervalCount,
				Algorithm: $scope.my.option,
				count: $scope.i,
				b_rate: $scope.bit_rate_update,
				k: $scope.k_nodes,
				dist: $scope.distance,
			}).
			success(function(data, status, headers, config){
				$scope.Interval = data.pdr_set;
				//test this after you know interval works
				$scope.feedbackNode = data.feedback_set;
				$scope.bit_rate_update = data.bit_rate;
			}).
			error(function(data, status)
			{
				$scope.Interval = [];
				$scope.feedbackNode = [];
				console.log("here");


			});
			
		};


		$scope.play();
	}]);
	</script>
</body>
</html>